# 开发笔记：网络游戏帧同步与状态同步总结

## 状态同步

所谓状态同步，是指对游戏中各种状态的表现的过程以及结果的同步。这种模式下，客户端会先发送要执行操作给服务器，服务器计算操作执行后的结果，如对目标击打是否命中、命中后造成多少伤害等，并广播计算结果给客户端。客户端收到操作结果后，执行表现逻辑，如击中后表现、伤害表现、动画以及特效等等。

状态同步适用于实时性要求不算太高，如MMORPG、回合制游戏等，因为游戏场景比较大，且场景数量也比较多，服务器就需要保存所有场景中的完整状态，并在状态变更后，只给需要同步状态的那部分玩家发现消息。

## 帧同步

帧同步与状态同步相比，其同步的是客户端的操作指令。这种模式下，客户端发送操作指令给服务器，服务器不对指令进行计算，只是按一定的频率（帧率）收集玩家的输入指令数据，如收集玩家上下左右移动、发射子弹指令等。然后统一把当前时间内收到的指令转发给所有客户端，客户端收到数据后，统一执行指令逻辑。

帧同步适用于实时性要求较高得游戏类型，比如即时战略游戏（RTS）、多人在线战斗竞技场游戏（MOBA），这种游戏通常要求对每一帧的效果都表现得淋漓尽致，且不能出现任何操作的不一致性。

### 帧循环

帧同步游戏中通常会有个游戏循环来不停的驱动游戏的继续运行，服务器和客户端在帧同步的方案下都会有一个桢循环来保证游戏的同步进行。

比如在 Unity 3D 引擎中，游戏主循环看起来是这样的：

## 状态同步与帧同步比较

### 延迟

我们把游戏种延迟表现分为3个等级：流畅、轻微卡顿，明显卡顿。

状态同步中，实时性并不要求很高，如回合制游戏中操作延迟感受：

- 500毫秒，游戏中的体验非常好，玩家交互等将非常流程。
- 2s - 3s，服务器会轻微卡顿。
- 3s 以上，服务器比较卡，玩家体验将很差。

而桢同步中，实时性通常要求比较高，如格斗游戏中延迟感受：

- 100毫秒，会非常流程。
- 150毫秒，会出现轻微卡顿。
- 200毫秒，明显卡顿，体验非常差。

我们可以看到在状态同步的模式下，即使500毫秒的延迟，整个游戏体验就会非常好，而帧同步到了200毫秒延迟就达到了恶劣的游戏环境。

### 反外挂

状态同步因为大部分计算的核心逻辑都放在服务器，所以对于外挂来说基本都可以很容易就直接检测出来，所以其安全性会比桢同步较高，且检查外挂难度较低。

帧同步不同于状态同步指出在于服务器并没有一个完成的状态信息，其只保存着每个桢循环的操作逻辑数据。所以在反外挂方面会需要下更多的功夫。对于桢同步反外挂，可以下面这些操作：

- 所有操作获得收益，都设置区间，如伤害数值上限、操作次数上限，如果超过合理区间，则视为错误操作。
- 快速回放所有历史数据进行结果校验。
- 客户端每一步操作都生成一个校验和，如通过计算操作的血量、魔法值、位置等得出校验和，然后对比多个客户端的操作是否一致，但这种校验手段通常适合于多人游戏中。

### 断线重连

状态同步中，服务器保存着当前游戏中的所有状态，所以短线重连时只需要下发当前状态给客户端，客户端就能根据服务器下发的信息恢复到游戏当前的状态。比如回合制战斗中，客户端重连后，重新进入战场，只需要恢复当前所有战斗角色的血量以及更新当前回合状态即可。

而到了帧同步就大不一样了，如果是实时战斗的游戏，首先服务器并没有当前战场的状态，服务器只保存着这个战场内所有桢循环的操作输数据，所以，客户端在断线重连后，需要获取到所有逻辑桢的数据，并快速播放所有桢操作，知道追上当前游戏状态。

### 实现难度

状态同步开发过程中，客户端与服务器可以相互独立的进行，其分工比较明确，客户端负责输入和输出后的表现，服务器负责计算输入，并输出结果。因为游戏运行并不要求所有客户端都表现一致，所以联调成本较低，BUG 触发后，比较容易定位。

帧同步更多的是要求所有客户端对同一份桢数据运行结果的一致性，所以在不同的环境上面，可能会因为某一环节的出错造成整体结果的不一致，在定位问题时通常难度会比较大，需要制定高效率的自动化测试系统，对问题反复测试，输出合理的日志进行对比追踪，最后得出为题所在。

### 网络流量

在帧同步实现中，因为其只转发客户端操作，会造成一种帧同步流量一定比状态同步流量少的假象。而事实上，在许多帧同步实现中，为了对抗网络延迟，所以很多实现通常采用对 UDP 来设计，通过额外封装使 UDP 成为一个可靠的协议，这就需要 UDP 数据包传输过程中增加额外的桢数据，来提升传输成功率，另外 UDP 实现的中重发频率会比 TCP 来的更快。

## 总结

状态同步是游戏中常见的开发模式，其安全性高、开发难度较低，但因为计算任务较多，所以服务器承载压力会比较大。另外，采用状态同步，灵活性也会比较大，其可以针对性的优化客户端性能。

帧同步更倾向于单机类游戏的开发模式，服务器要做的工作远低于状态同步，所以开发效率会比状态同步高，这一特点也使得服务器的消耗比状态同步更低。
---
title: 《C语言接口与实现：创建可重用的软件技术》读书笔记
date: 2017-12-09 22:39:00
categories: 读书笔记
tags: [C语言, 接口与实现]
---

如今的程序员忙于应付大量关于 API（ Application Programming Interface）的信息。但是，大多数程序员都会在其所写的几乎每一个应用程序中使用 API 并实现 API 的库，只有少数程序员会创建或发布新的能广泛应用的 API。

事实上，程序员似乎更喜欢使用自己搞的东西，而不愿意查找能满足他们要求的程序库，这或许是因为写特定应用程序的代码要比设计可广泛使用的API 容易。

本书提倡的是一种基于接口及其实现的设计方法，并且通过对 24 个接口及其实现的描述详细演示了该方法。这些接口涉及很多计算机领域的知识，包括数据结构、算法、字符串处理和并发程序。这些实现并不是简单的玩具，而是为在产品级代码中使用而设计的。实现的代码是可免费提供的

基于接口的设计跟具体的语言无关，但是它要求程序员对像 C 一样的语言有更强的驾驭能力和更高的警惕性，因为这类语言很容易破坏带有隐含实现信息的接口，反之亦然。

<!--more-->

## 程序设计风格
一般来说，较长且富于语义的名称用于全局变量和例程，而数学符号般的短名称则用于局部变量。

对索引和变量使用较长的名称通常会使代码更难阅读。
```
for (theindex = 0; theindex < numofElements; theindex++)
	sum += x[theindex]*y[theindex];
```

变量的声明应该靠近于其第一次使用的地方（可能在代码块中）。

过程和函数的名称，应能反映过程完成的工作及函数的返回值。

代码中几乎没有注释，因为围绕对应代码块的正文代替了注释。如果代码很清晰，且使用了良好的命名和缩进惯例， 则这样的代码通常是含义自明的。仅当进行解释时（例如，解释数据结构的细节、算法的特例以及异常情况）才需要注释。
编译器无法检查注释是否与代码一致，误导的注释通常比没有注释更糟糕。最后，有些注释只不过是一种干扰，其中的噪音和过
多的版式掩盖了注释内容， 从而使这些注释只会掩盖代码本身的含义。


## 效率
程序员似乎被效率问题困扰着。他们可能花费数小时来微调代码，使之运行得更快。遗憾的是，大部分这种工作都是无用功。当猜测程序的运行时间花费在何处时，程序员的直觉非常糟糕。
微调程序是为了使之更快， 但通常总是会使之更大、更难理解、更可能包含错误。除非对执行时间的测量表明程序太慢，否则这样的微调没有意义。程序只需要足够快即可，不一定要尽可能快。

- 微调通常会引入错误。最快崩溃的程序绝非胜者。可靠性比效率更重要；与交付足够快的可靠软件相比，交付快速但会崩溃的软件，从长远看来代价更高。
- 微调经常在错误的层次上进行。快速算法的直接简明的实现，比慢速算法的手工微调实现要好得多。例如，减少线性查找的内层循环的指令数，注定不如直接使用二分查找。
- 微调无法修复低劣的设计。如果程序到处都慢，这种低效很可能是设计导致的。当基于编写得很糟糕或不精确的问题说明给出设计时，或者根本就没有总体设计时，就会发生这种令人遗憾的情况。

学习编写高效的代码，最好的方法是在算法方面有扎实的基础，并阅读其他高效的代码。


## 接口与实现
模块分为两个部分，即模块的接口与实现。接口规定了模块做什么。接口会声明标识符、类型和例程，提供给使用模块的代码。实现指明模块如何完成其接口规定的目标。对于给定的模块，通常只有一个接口，但可能有许多实现提供了接口规定的功能。每个实现可能使用不同的算法和数据结构，但它们都必须合乎接口的规定。
客户程序（ client）是使用模块的一段代码。客户程序导入接口，实现则导出接口。客户程序只需要看到接口即可。

### 接口
接口仅规定客户程序可能使用的那些标识符，而尽可能隐藏不相关的表示细节和算法。这有助于客户程序避免依赖特定实现的具体细节
。
在 C 语言中，接口通过一个头文件指定，头文件的扩展名通常为.h。这个头文件会声明客户程序可能使用的宏、类型、数据结构、变量和例程。客户程序用 C 预处理器指令#include 导入接口。

### 实现
实现会导出接口。它定义了必要的变量和函数，以提供接口规定的功能。实现具体解释了接口的语义，并给出其表示细节和算法，但在理想情况下，客户程序从来都不需要看到这些细节。

一个接口可以有多个实现。只要实现遵循接口的规定，完全可以在不影响客户程序的情况下改变实现。在 C 语言中，一个实现通过一个或多个.c 文件来提供。实现必须提供其导出的接口规定的功能。实现会包含接口的.h 文件，以确保其定义与接口的声明一致。

### 抽象数据类型
一个抽象数据类型是一个接口，它定义了一个数据类型和对该类型的值所进行的操作。一个数据类型是一个值的集合。在 C语言中，内建的数据类型包括字符、整数、浮点数等。而结构本身也能定义新的类型，因而可用于建立更高级类型，如列表、树、查找表等。

### 客户程序的职责
接口是其实现和其客户程序之间的一份契约。实现必须提供接口中规定的功能，而客户程序必须根据接口中描述的隐式和显式的规则来使用这些功能。

C 语言的用法没有规定的或编译器无法检查的规则，必须在接口中详细说明。客户程序必须遵循这些规则，实现必须执行这些规则。

接口通常会规定：
- 未检查的运行时错误（ unchecked runtime error）
未检查的运行时错误是对客户程序与实现之间契约的破坏， 而实现并不保证能够发现这样的错误。如果发生未检查的运行时错误， 可能会继续执行，但结果是不可预测的，甚至可能是不可重复的。好的接口会在可能的情况下避免未检查的运行时错误，但必须规定可能发生的此类错误。

- 已检查的运行时错误（ checked runtime error）
已检查的运行时错误是对客户程序与实现之间契约的破坏，但实现保证会发现这种错误。这种错误表明，客户程序未能遵守契约对它的约束， 客户程序有责任避免这类错误。

- 异常（ exception）。
接口可以规定异常及引发异常的条件。


## 原子
原子（ atom）是一个指针，指向一个唯一的、不可变的序列，序列中包含零或多个字节（字节值任意）。大多数原子都指向 0 结尾字符串，但也可以是指向任一字节序列的指针。任一原子都只会出现一次，这也是它被称为原子的原因。如果两个原子指向相同的位置，那么二者是相同的。原子的一个优点是，只通过比较两个指针，即可比较两个字节序列是否相等。使用原子的另一个优点是节省空间，因为任一序列都只会出现一次。

Atom 接口：
```
<atom.h>

#ifndef ATOM_INCLUDED
#define ATOM_INCLUDED

extern int Atom_length(const char *str);
extern const char *Atom_new (const char *str, int len);
extern const char *Atom_string(const char *str);
extern const char *Atom_int (long n);

#endif
```

Atom_new 的参数包括一个指向字节序列的指针，以及该序列中的字节数目。
Atom_string 函数接受一个 0 结尾字符串作为参数，（如有必要）将该字符串的一个副本添加到原子表，并返回该原子。
Atom_int 返回对应于以字符串表示长整数 n 的原子，这是另一种常见的用法。
Atom_length 的执行时间与原子的数目成正比。 


## 异常与断言
程序中会发生三种错误：用户错误、运行时错误和异常。
用户错误是预期会发生的，因为错误的用户输入就可能会导致用户错误。此类错误的例子，包括命名不存在的文件、在电子表格中指定格式错误的数字以及向编译器提交语法错误的源程序等。程序必须预计到这种错误并妥善处理。通常，必须处理用户错误的函数会返回错误码，这种错误是计算过程的一个普通组成部分。
已检查的运行时错误不是用户错误。它们从来都是非预期的，总是表明程序出现了 bug。因而，应用程序无法从这种错误恢复，而必须优雅地结束。使用断言（ assertion）来捕获这种错误。

### 断言
C 语言标准要求头文件 assert.h 将 assert(e)定义为宏，来提供诊断信息。 assert(e)会计算表达式 e 的值，如果 e 为 0，则向标准错误输出（ stderr）写出诊断信息，并调用标准库函数abort 放弃程序的执行。诊断信息包含失败的断言（即表达式 e 的文本）和断言（ e）出现的坐标（文件和行号）。



## 链表
链表是零或多个指针的序列。包含零个指针的链表是空链表。链表中指针的数目是其长度。几乎每个非平凡的应用程序都会以某种形式使用链表。
链表很容易实现，因此程序员通常对手头的每个应用程序都重新实现链表，另外，虽然大多数特定于应用程序的链表接口有很多相似性，但链表没有广为接受的标准接口。

链表很容易实现，因此程序员通常对手头的每个应用程序都重新实现链表，另外，虽然大多数特定于应用程序的链表接口有很多相似性，但链表没有广为接受的标准接口。如下所述的 List抽象数据类型提供了大多数特定于应用程序的链表接口中的许多功能。


完整的 List 接口如下：
```
#ifndef LIST_INCLUDED
#define LIST_INCLUDED

#define T List_T
typedef struct T *T;

struct T {
T rest;
void *first;
};

extern T List_append (T list, T tail);
extern T List_copy (T list);
extern T List_list (void *x, ...);
extern T List_pop (T list, void **x);
extern T List_push (T list, void *x);
extern T List_reverse(T list);
extern int List_length (T list);
extern void List_free (T *list);
extern void List_map (T list,
void apply(void **x, void *cl), void *cl);
extern void **List_toArray(T list, void *end);

#undef T
#endif
```


## 集合
集合（ set）是不同成员的无序汇集。对集合的基本操作包括检验成员资格、添加成员和删除成员。 其他操作包括集合的并、交、差和对称差。给定两个集合 s 和 t，并集 s + t 是包含 s和 t 中所有成员的一个集合，交集 s * t 包含所有既出现在 s 中、也出现在 t 中成员，差集 s - t包含所有仅出现在 s 中、而不出现在 t 中的成员，对称差集通常记作 s / t，包含了所有仅出现在 s 或 t 其中之一的成员。

描述集合时，通常会用到全集（ universe）， 即所有可能成员的集合。例如，字符的集合通常关联到由 256 个八位字符码构成的全集。当确定了全集 U 时，可以定义集合 s 的补集，即 U - s。

```
#ifndef SET_INCLUDED
#define SET_INCLUDED

#define T Set_T

typedef struct T *T;
extern T Set_new (int hint,
	int cmp(const void *x, const void *y),
	unsigned hash(const void *x));
extern void Set_free(T *set);

#undef T
#endif
```